# 操作记录

## 2026/1/29

### 步骤 1：修复 config.py 中的错误 ✅

**问题描述：**
- 文件：`config.py`
- 行号：第 12 行
- 错误：`uuid.uuid4(2112381080)` - Pylance 报错"应为 0 个位置参数"

**原因分析：**
- `uuid.uuid4()` 函数用于生成随机 UUID，不接受任何参数
- 代码中错误地传递了 `2112381080` 作为参数

**修复方案：**
- 将 `uuid.uuid4(2112381080)` 改为 `uuid.uuid4()`

**修复后代码：**
```python
"X-Api-Connect-Id": str(uuid.uuid4()),
```

**状态：** 已完成 ✅

---

### 步骤 8：精简代码 ✅

**需求：** 只保留 AI 实时对话的核心功能，删除多余代码

**修改文件：**

#### audio_manager.py
删除的功能：
- `trigger_chat_tts_text()` - 安抚话术功能
- `trigger_chat_rag_text()` - RAG 外部数据查询功能
- `process_text_input()` - 文本输入模式
- `process_microphone_input()` - 麦克风输入模式
- `input_listener()` - 标准输入监听
- `_audio_player_thread()` - 音频播放线程
- `AudioDeviceManager` 类 - 音频设备管理（麦克风/扬声器）
- `save_input_pcm_to_wav()` - 保存输入 PCM
- `save_output_to_file()` - 保存输出文件

保留的核心功能：
- `DialogSession` 类 - 对话会话管理
- `process_audio_file()` - 处理音频文件输入
- `receive_loop()` - 接收服务器响应
- `handle_server_response()` - 处理响应数据
- `start()` - 启动会话

#### api_server.py
删除的接口：
- `POST /api/dialog/text` - 文本对话接口

保留的接口：
- `POST /api/dialog/audio` - 音频对话接口
- `GET /api/dialog/output/{filename}` - 获取输出音频
- `GET /api/health` - 健康检查

#### main.py
更新命令行参数：
- `--audio` (必需) - 输入音频文件路径
- `--format` - 输出音频格式，默认 pcm
- `--timeout` - 接收超时时间，默认 30 秒

删除的参数：
- `--mod` - 模式选择（已移除，只支持音频文件模式）

**精简后的代码结构：**
```
audio_manager.py (约 130 行)
├── AudioConfig - 音频配置数据类
└── DialogSession - 对话会话类
    ├── __init__() - 初始化
    ├── handle_server_response() - 处理响应
    ├── receive_loop() - 接收循环
    ├── process_audio_file() - 处理音频文件
    └── start() - 启动会话
```

**使用方法：**
```bash
# 命令行测试
python main.py --audio whoareyou.wav

# API 服务
python api_server.py
```

**状态：** 已完成 ✅

---

### 步骤 2：安装依赖 ✅

**执行命令：**
```bash
conda activate py312
pip install -r requirements.txt
```

**执行结果：**
- 环境名称修正：`py12` → `py312`
- 依赖已安装：
  - `pyaudio` - 已安装
  - `websockets` - 已安装

**状态：** 已完成 ✅

---

### 步骤 3：创建 API 后端服务 ✅

**需求：** 前端传录音文件，后端处理并返回结果

**创建文件：** `api_server.py`

**使用框架：** FastAPI + Uvicorn

**新增依赖：**
- `fastapi` - Web 框架
- `uvicorn[standard]` - ASGI 服务器
- `python-multipart` - 文件上传支持

**API 接口说明：**

| 接口 | 方法 | 描述 |
|------|------|------|
| `/` | GET | 返回服务信息 |
| `/api/dialog/audio` | POST | 上传录音文件进行语音对话 |
| `/api/dialog/text` | POST | 发送文本进行对话（开发中） |
| `/api/dialog/output/{filename}` | GET | 获取对话输出音频文件 |
| `/api/health` | GET | 健康检查 |

**主要接口详情：**

#### POST /api/dialog/audio
上传录音文件进行语音对话

**请求参数：**
- `audio_file` (file, 必需): WAV 格式录音文件
- `recv_timeout` (int, 可选): 接收超时时间，默认 30 秒，范围 10-120

**响应示例：**
```json
{
    "success": true,
    "task_id": "uuid-string",
    "output_audio_url": "/api/dialog/output/xxx_output.pcm",
    "logid": "server-log-id",
    "message": "语音对话处理完成"
}
```

**状态：** 已完成 ✅

---

### 步骤 4：运行 API 服务 ✅

**启动命令：**
```bash
conda activate py312
python api_server.py
```

**服务地址：** http://localhost:8000

**API 文档地址：** http://localhost:8000/docs (Swagger UI)

**启动日志：**
```
INFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [25880] using WatchFiles
INFO:     Started server process [24984]
INFO:     Application startup complete.
```

**状态：** 已启动 ✅

---

### 步骤 5：创建前端测试页面 ✅

**需求：** 创建一个可以录音并发送到后端的测试页面

**创建文件：**
- `frontend/index.html` - 主页面（包含样式）
- `frontend/app.ts` - TypeScript 源码
- `frontend/app.js` - JavaScript 编译版本
- `frontend/tsconfig.json` - TypeScript 配置

**功能说明：**
1. 点击麦克风按钮开始录音
2. 再次点击停止录音
3. 自动将录音转换为 WAV 格式
4. 上传到后端 `/api/dialog/audio` 接口
5. 接收并播放 AI 回复音频

**技术实现：**
- 使用 Web Audio API + MediaRecorder 进行浏览器录音
- 录音格式：WebM → WAV 转换
- 使用 Fetch API 上传文件
- 使用 Audio API 播放响应

**前端页面地址：** `frontend/index.html`（直接用浏览器打开）

**状态：** 已完成 ✅

---

### 步骤 6：添加调试信息面板 ✅

**需求：** 在前端页面添加调试面板，显示后端返回的详细信息

**修改文件：**
- `frontend/index.html` - 添加调试面板 HTML 和 CSS
- `frontend/app.js` - 添加调试日志功能

**调试面板功能：**
- 显示时间戳、日志类型（INFO/SUCCESS/ERROR/REQUEST/RESPONSE）
- 显示详细的请求和响应数据（JSON 格式）
- 支持清空日志
- 自动滚动到最新日志

**显示的信息包括：**
- 页面初始化状态
- 浏览器录音功能支持情况
- 后端服务连接状态
- 录音开始/停止事件
- 音频转换过程
- 上传请求和响应（task_id、logid、audio_received、audio_size）
- 错误信息和堆栈跟踪

**状态：** 已完成 ✅

---

### 步骤 7：添加会话文件数量限制 ✅

**需求：** uploads 和 outputs 目录最多只保留 5 个会话的文件

**修改文件：** `api_server.py`

**实现方案：**

1. 添加配置常量：
```python
MAX_SESSIONS = 5  # 最多保留的会话数量
```

2. 添加清理函数：
```python
def cleanup_old_files(directory: str, max_files: int = MAX_SESSIONS) -> int:
    """
    清理目录中的旧文件，只保留最新的 N 个文件
    - 按文件修改时间排序
    - 删除超出限制的旧文件
    """
```

3. 在每次请求处理完成后调用清理：
```python
finally:
    cleanup_old_files(UPLOAD_DIR, MAX_SESSIONS)
    cleanup_old_files(OUTPUT_DIR, MAX_SESSIONS)
```

**效果：**
- 每次新上传后，自动检查并删除超出 5 个的旧文件
- uploads 和 outputs 目录各自最多保留 5 个文件
- 按文件修改时间排序，保留最新的

**状态：** 已完成 ✅
